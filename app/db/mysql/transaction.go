// Generated by the Model Generate Tool. DO NOT EDIT!

package mysql

import (
	"database/sql"
	"errors"
	"fmt"
	"time"
)

// Table name: transactions
type Transaction struct {
	Id             int64     `json:"id"`              // id bigint
	HashId         int64     `json:"hash_id"`         // hash_id varchar
	HashIndex      int64     `json:"hash_index"`      // hash_index int
	FromAddressId  int64     `json:"from_address_id"` // from_address_id bigint
	ToAddressId    int64     `json:"to_address_id"`   // to_address_id bigint
	BlockNumber    int64     `json:"block_number"`    // block_number bigint
	Amount         string    `json:"amount"`          // amount varchar
	TokenId        int64     `json:"token_id"`        // token_id bigint
	GasUsed        string    `json:"gas_used"`        // gas_used bigint
	GasPrice       string    `json:"gas_price"`       // gas_price varchar
	Value          string    `json:"value"`           // value varchar
	InoutType      int64     `json:"inout_type"`      // inout_type tinyint
	BlockTimestamp int64     `json:"block_timestamp"` // block_timestamp int
	CreatedAt      time.Time `json:"created_at"`      // created_at datetime
	UpdatedAt      time.Time `json:"updated_at"`      // updated_at datetime
}

func GetTransactionByHash(hashId int64, hashIndex int64) (int64, error) {

	var id int64

	if err := DBQueryRow(
		"SELECT id FROM transactions WHERE `hash_id`=? AND `hash_index` = ?",
		hashId,
		hashIndex,
	).Scan(&id); err != nil {
		return 0, err
	}

	return id, nil
}

func InsertTransaction(tx *Transaction) (int64, error) {
	var id int64

	result, err := DBExec(
		"INSERT INTO transactions (hash_id, hash_index, from_address_id, to_address_id, block_number, amount, token_id, block_timestamp, gas_used, gas_price, value, inout_type, created_at, updated_at) values (?,?,?,?,?,?,?,?,?,?,?,?,now(),now())",
		tx.HashId,
		tx.HashIndex,
		tx.FromAddressId,
		tx.ToAddressId,
		tx.BlockNumber,
		tx.Amount,
		tx.TokenId,
		tx.BlockTimestamp,
		tx.GasUsed,
		tx.GasPrice,
		tx.Value,
		tx.InoutType,
	)
	if err != nil {
		return 0, err
	}

	id, err = result.LastInsertId()
	if err != nil {
		return 0, err
	}

	return id, nil
}

func InsertTransactionIfNotExist(tx *Transaction) (int64, error) {
	id, err := GetTransactionByHash(tx.HashId, tx.HashIndex)
	if err == nil {
		return id, nil
	}
	if err != sql.ErrNoRows {
		return 0, err
	}

	return InsertTransaction(tx)
}

func InsertTransactionIfNotExistWithPanic(tx *Transaction) {
	id, err := InsertTransactionIfNotExist(tx)
	if err == nil && id <= 0 {
		err = errors.New(fmt.Sprintf("Insert tx err, invalid id=%d", id))
	}

	if err != nil {
		panic(fmt.Sprintf("Get hash err, hash: %d, err: %s", tx.HashId, err.Error()))
	}
}
